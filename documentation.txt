Udemy Course Mastering React Testing: RTL, Vitest & MSW - John Smilga


Section 01: Introduction

01. Course Info


Section 02: React Testing Library Tutorial

02. Main Course Repo !!! Important !!!

03. Install/Setup Course Repository
-otvorimo link: https://www.npmjs.com/package/@testing-library/react
-otvorimo web stranicu: https://vite.dev/guide/
-preuzmemo folder 01-rtl-tutorial sa startnim folderima i fajlovima
-u terminalu udemo u folder cd 01-rtl-tutorial i ukucamo komandu npm i
-u jednom terminalu ukucamo komandu npm run dev
-u drugom terminalu ukucamo komandu npm test

04. Files and Folders

05. Explore First Test File
-otvorimo App.test.tsx komponentu

06. Test Validation Details

07. Vitest Info
-otvorimo web stranicu: https://vitest.dev

Quiz 1: React Testing Library Essentials Quiz

08. <SearchByText /> - Component
-kreiramo folder starter sa tsx komponentama
-u eslint.config.js fajl dodajemo opciju: '@typescript-eslint/no-unused-vars': 'warn'
-u komponentu Sandbox.tsx importujemo funkcije useState i useEffect iz biblioteke React
-u komponentu App.tsx importujemo komponentu Sandbox.tsx

09. SearchByText Methods - Overview

10. SearchByText Methods - Test File
-u folderu tutorial/01-search-by-text kreiramo komponentu Sandbox.test.tsx
-u komponentu Sandbox.test.tsx importujemo funkcije render i screen iz paketa testing-library/react
-importujemo komponentu Sandbox.tsx
-pozivamo funkciju describe() sa dva argumenta
-prvi argument funkcije describe() je opis testova, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju test() sa dva argumenta
-prvi argument funkcije test() je opis testa, dok je drugi argument anonimna asinhrona funkcija
-u anonimnoj asinhronoj funkciji pozivamo funkcije render(<Sandbox />) i screen.debug()
-kreiramo varijablu const heading
-pozivamo funkciju expect(heading).toBeInTheDocument()
-pozivamo funkciju expect(screen.getByText(/react/i)).toBeInTheDocument()
-kreiramo varijable const phoneRegex i const phoneText
-pozivamo funkciju expect(phoneText).toBeInTheDocument()
-kreiramo varijablu const errorMessage 
-pozivamo funkciju expect(errorMessage).not.toBeInTheDocument()
-kreiramo varijablu const items
-pozivamo funkciju expect(items).toHaveLength(3)
-kreiramo varijablu const asyncMessage
-pozivamo funkciju expect(asyncMessage).toBeInTheDocument()

11. Test Driven Development Example
-u folderu tutorial/02-tdd-example kreiramo komponentu Sandbox.test.tsx
-u komponentu Sandbox.test.tsx importujemo funkcije render i screen iz paketa testing-library/react
-importujemo komponentu Sandbox.tsx
-pozivamo funkciju describe() sa dva argumenta
-u funkciji describe() prvi argument je opis testova, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju test() sa dva argumenta
-u funkciji test() prvi argument je opis testa, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render()
-kreiramo varijablu const heading
-pozivamo funkciju expect(heading).toBeInTheDocument()
-u komponentu App.tsx importujemo komponentu Sandbox.tsx iz foldera tutorial/02-tdd-example

Quiz 2: React Testing Library Query Methods and TDD Basics Quiz

12. <SearchByRole /> Component
-u komponentu App.tsx importujemo komponentu Sandbox.tsx iz foldera tutorial/03-search-by-role
-u komponentu Sandbox.tsx importujemo funkcije useState i useEffect iz biblioteke React

13. SearchByRole Methods Overview
-otvorimo link: https://testing-library.com/docs/queries/about

14. SearchByRole Test File
-u komponentu Sandbox.test.tsx importujemo funkcije render i screen iz paketa testing-library/react
-importujemo komponentu Sandbox.tsx
-pozivamo funkciju describe() sa dva argumenta
-prvi argument je opis testova za nav element i navigacione elemente, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />)
-pozivamo funkciju expect(screen.getByRole('navigation')).toBeInTheDocument()
-pozivamo dvije funkcije expect() za linkove Home i About
-importujemo funkcija logRoles iz paketa testing-library/react
-vrijednost funkcije render(<Sandbox />) pohranjujemo u destruktuiranu varijablu const { container }
-pozivamo funkciju logRoles(container)
-pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za renderovanja naslova sa tacnim redoslijedom, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />)
-pozivamo dvije funkcije expect(screen.getByRole('heading', { ... }))
-pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za renderovanja img elementa, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />)
- pozivamo funkciju expect(screen.getByRole('img', { ... }))
-pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za renderovanja button elemenata, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />)
-pozivamo tri funkcije expect(screen.getByRole('button', { .. }))
-pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za renderovanja button error elementa, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />) 
-pozivamo funkciju expect(screen.queryByRole('button', { ... })) 
-pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za renderovanja asinhronog button elementa, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />) 
-kreiramo varijablu const buttonName
-pozivamo funkciju expect(screen.queryByRole('button', { ... }))
-kreiramo varijablu const asyncButton
-pozivamo funkciju expect(asyncButton).toBeInTheDocument()

15. User Interactions Component
-otvorimo link: https://testing-library.com/docs/user-event/intro/#differences-with-fireevent
-u komponentu App.tsx importujemo komponentu Sandbox.tsx iz foldera tutorial/04-user-interactions
-u komponentu 04-user-interaction/Sandbox.tsx importujemo funkciju useState iz biblioteke React
-importujemo ikonice FaHeart i FaRegHeart iz paketa React Icons

16. User Interactions - Test File
-otvorimo link: https://www.npmjs.com/package/@testing-library/user-event
-u folderu tutorial/04-user-interactions kreiramo komponentu Sandbox.test.tsx
-u komponentu Sandbox.test.tsx importujemo funkcije render, screen i fireEvent iz paketa testing-library/react
-importujemo funkciju userEvent() iz paketa testing-library/user-event
-pozivamo funkciju describe() sa dva argumenta
-prvi argument je opis testova, dok je drugi argument anonimna funkcija
-u komponenti Sandbox.tsx button elementima dodajemo atribut aria-label
-u funkciji describe() pozivamo cetiri funkcije test()

Quiz 3: React Testing Library: Search By Role and User Interactions Quiz

17. Form Testing - Sandbox
-otvorimo link: https://www.npmjs.com/package/validator
-u komponentu App.tsx importujemo komponentu Sandbox iz foldera tutorial/05-form-testing
-u komponentu Sandbox.tsx importujemo funkcije useState i validator
-kreiramo varijablu objekt const defaultState
-kreiramo varijable const labelStyles, inputStyles i buttonsStyles
-u funkciji Sandbox() kreiramo state varijablu const signupInput i set funkciju setSignupInput
-kreiramo state varijablu const error i set funkciju setError
-kreiramo funkcije handleChange() i handleSubmit()
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u roditelj div elementu kreiramo form element
-u form elementu kreiramo tri div element za email, sifru i potvrdi sifru elemente
-dodajemo uslov za kondicionalno renderovanje error &&
-kreiramo button element sa prop type, onClick i className 
-funkciji handleChange() dodajemo parametar e sa tipom
-u funkciji handleChange() destruktuiramo varijable const { id, value }
-pozivamo funkciju setSignupInput()
-funkciji handleSubmit() dodajemo parametar e sa tipom
-u funkciji handleSubmit() pozivamo funkciju e.preventDefault()
-dodajemo uslove if za validaciju email adrese i unesenih sifri
-u uslove if dodajemo izjavu return setError()
-u funkciji handleSubmit() pozivamo funkciju setSignupInput(defaultState)

18. Test Empty Inputs
-kreiramo komponentu Sandbox.test.tsx
-u komponentu Sandbox.test.tsx importujemo funkcije render i screen iz paketa testing-library/react
-importujemo komponentu Sandbox.tsx
-pozivamo funkciju describe() sa dva argumenta
-prvi argument je opis testova, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za testiranje input elemenata da budu inicijalno prazna, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<Sandbox />)
-vrijednost funkcije render(<Sandbox />) pohranjujemo u destruktuiranu varijablu const { container }
-pozivamo funkciju screen.debub()
-pozivamo funkciju logRoles(container)
-kreiramo varijablu const emailInputElement
-pozivamo funkciju expect(emailInputElement).toHaveValue('')
-kreiramo varijablu const passwordInputElement
-pozivamo funkciju expect(passwordInputElement).toHaveValue('')
-kreiramo varijablu confirmPasswordInputElement
-pozivamo funkciju expect(confirmPasswordInputElement).toHaveValue('')
-u vite.config.js fajlu, u niz exclude dodajemo imena foldera u kojima ne zelimo da se testovi pokrecu

19. Test Typing in The Inputs
-u komponentu Sandbox.test.tsx importujemo funkciju userEvent iz paketa testing-library/user-event
-pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za testiranje input elemenata da se mogu unijeti podaci, dok je drugi argument asinhrona anonimna funkcija
-u asinhronoj anonimnoj funkciji kreiramo varijablu const user
-pozivamo funkciju render(<Sandbox />)
-kreiramo varijable const emailInputElement, passwordInputElement i confirmPasswordInputElement
-pozivamo funkciju await user.type(emailInputElement, 'test@test.com')
-pozivamo funkciju expect(emailInputElement).toHaveValue('test@test.com')
-pozivamo funkciju await user.type(passwordInputElement, 'secret')
-pozivamo funkciju expect(passwordInputElement).toHaveValue('secret')
-pozivamo funkciju await user.type(confirmPasswordInputElement, 'secret')
-pozivamo funkciju expect(confirmPasswordInputElement).toHaveValue('secret')

20. Refactor
-u komponenti Sandbox.test.tsx kreiramo funkciju getFormElements()
-u funkciji getFormElements() kreiramo varijablu objekt const elements
-u objektu elements kreiramo key - value parove emailInputElement, passwordInputElement, confirmPasswordInputElement i submitButton
-u funkciju getFormElements() dodajemo izjavu return elements
-u funkciji test() za inicijalno prikazivanje input elemenata kao prazna polja pozivamo funkciju getFormElements()
-vrijednost funkcije getFormElements() pohranjujemo u destruktuirane varijablu: const { emailInputElement, passwordInputElement, confirmPasswordInputElement }
-pozivamo tri funkcije expect()
-u funkciji test() za testiranje input elemenata da se mogu unijeti podaci pozivamo funkciju getFormElements()
-vrijednost funkcije getFormElements() pohranjujemo destruktuiranu varijablu const { emailInputElement, passwordInputElement, confirmPasswordInputElement } 
-otvorimo link: https://www.npmjs.com/package/vitest
-importujemo funkciju beforeEach iz paketa Vitest
-u funkciji describe() pozivamo funkciju beforeEach()
-importujemo tip UserEvent iz paketa testing-library/user-event
-u funkciji describe() kreiramo varijablu let user sa tipom UserEvent
-u funkciji beforeEach() redeklarisemo varijablu user sa vrijednoscu userEvent.setup()

21. Form Testing - Remaining Tests
-u komponenti Sandbox.test.tsx pozivamo funkciju test() sa dva argumenta
-prvi argument je opis testa za prikazivanje poruke greska ako email nije validan, dok je drugi argument anonimna asinhrona funkcija
-u funkciji test() pozivamo funkciju getFormElements()
-vrijednoscu funkcije getFormElements() pohranjujemo u destruktuirane varijable const { emailInputElement, submitButton }
-pozivamo funkciju expect()
-pozivamo funkciju await user.type(emailInputElement, 'invalid')
-pozivamo funkciju await user.click(submitButton)
-pozivamo funkciju expect()
-pozivamo funkciju test()
-prvi argument je opis testa za prikazivanje poruke greska ako sifra nije validna, dok je drugi argument anonimna asinhrona funkcija
-u funkciji test() pozivamo funkciju getFormElements()
-vrijednoscu funkcije getFormElements() pohranjujemo u destruktuirane varijable const { emailInputElement, passwordInputElement, submitButton }
-pozivamo funkciju expect()
-pozivamo dvije funkcije await user.type() i jednu funkciju await user.click()
-pozivamo funkciju expect()
-pozivamo funkciju test()
-prvi argument je opis testa za prikazivanje poruke greska ukoliko se sifre ne podudaraju, dok je drugi argument anonimna asinhrona funkcija
-u funkciji test() pozivamo funkciju getFormElements()
-vrijednost funkcije getFormElements() pohranjujemo u cetiri destruktuirane varijable
-pozivamo funkciju expect()
-pozivamo tri funkcije await user.type() i jednu funkciju await user.click()
-pozivamo funkciju expect()
-pozivamo funkciju test()
-prvi argument je opis testa za neprikazivanje poruke greska nakon uspjesnog slanja forme, dok je drugi argument anonimna asinhrona funkcija
-u funkciji test() pozivamo funkciju getFormElements()
-vrijednost funkcije getFormElements() pohranjujemo u cetiri destruktuirane varijable
-pozivamo tri funkcije await user.type() i jednu funkciju await user.click()
-pozivamo tri funkcije expect() i queryByText()
-pozivamo tri funkcije expect() i toHaveValue()

Quiz 4: Form Testing in React: Best Practices

22. Reviews App - Logic
-u komponentu App.tsx importujemo komponentu Sandbox.tsx iz foldera tutorial/06-reviews-app
-kreiramo komponente Form.tsx i List.tsx
-u komponentu Sandbox.tsx importujemo funkciju useState, komponente Form.tsx i List.tsx
-kreiramo i eksportujemo tip Review
-pozivamo funkciju useState() sa tipom <Review[]>
-kreiramo state varijablu const reviews i set funkciju setReviews
-kreiramo funkciju addReview() sa parametrom review
-parametru review dodajemo tip Review
-u funkciju addReview() dodajemo funkciju setReviews()
-roditelj div elementu dodajemo Tailwind CSS klase
-kreiramo h2 element
-u roditelj div element dodajemo komponente Form i List
-komponenti Form dodajemo prop onSubmit
-komponenti List dodajemo prop reviews
-u komponenti Form.tsx kreiramo tip ReviewFormProps
-importujemo tip Review iz komponente Sandbox.tsx
-importujemo funkcije useState i tip FormEvent iz biblioteke React
-funkciji Form() dodajemo parametar destruktuirani prop onSubmit sa tipom ReviewFormProps
-kreiramo state varijable email, rating, text i textError
-kreiramo set funkcije setEmail, setRating, setText i setTextError
-kreiramo funkciju handleSubmit() sa parametrom e
-parametru e dodajemo tip FormEvent
-u funkciju handleSubmit() dodajemo metodu e.preventDefault()
-u jsx-u kreiramo roditelj form element sa dogadajem onSubmit i prop className
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit
-u form elemenata kreiramo tri div elementa za unos podataka za email, ocjenu i recenziju
-u div element za recenziju dodajemo uslov za kondicionalno renderovanje textError && 
-kreiramo button element sa prop type i className
-u funkciju handleSubmit() dodajemo uslove if (text.length >= 10) i else
-u uslov else dodajemo funkciju setTextError()
-u uslovu if kreiramo varijablu const newReview
-dodajemo funkciju onSubmit(newReview)
-dodajemo set funkcije setEmail(''), setRating(''), setText('') i setTextError('')
-u komponentu List.tsx importujemo tip Review iz komponentama Sandbox.tsx
-kreiramo tip ListProps
-funkciji List() dodajemo parametar destruktuirani prop reviews sa tipom ListProps
-u roditelj div elementu kreiramo h2 element
-dodajemo uslov ternarni operator reviews.length === 0
-u prvi dio ternarnog uslova dodajemo p element
-u drugi dio ternarnog uslova dodajemo metodu reviews.map()
-u funkciji map() kreiramo element article
-elementu article dodajemo prop key i className
-u elementu article kreiramo dva div elementa
-kreiramo p element

23. Reviews App - List Component Unit Tests
-kreiramo folder __tests__ 
-u folderu __tests__ kreiramo komponentu List.test.tsx komponentu
-u komponentu List.test.tsx importujemo funkcije render i screen iz paketa testing-library/react
-importujemo tip Review iz komponente Sandbox.tsx
-importujemo komponentu List.tsx
-importujemo funkcije describe, test i expect iz paketa Vitest
-pozivamo funkciju describe() sa dva argumenta
-prvi argument je opis testova, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkcija test() sa dva argumenta
-u funkciji test() prvi argument je opis testa za renderovanje naslova, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render()
-u funkciju render() proslijedujemo komponentu List sa prop reviews
-u prop review proslijedujemo prazan niz
-pozivamo funkciju expect()
-kreiramo varijablu niz const mockReviews sa tipom Review[]
-u prop reviews proslijedujemo niz mockReviews
-pozivamo funkciju test() sa dva argumenta
-u funkciji test() prvi argument je opis testa za prikazivanje poruke da nema recenzija ukoliko je niz recenzija prazan, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju render(<List reviews={[]} />)
-pozivamo funkciju expect()
-pozivamo funkciju test() sa dva argumenta
-u funkciji test() prvi argument je opis testa za prikazivanje recenzija ukoliko postoje ispravni podaci, dok je drugi argument anonimna funkcija
-u anonimnoj funkciji pozivamo funkciju  render(<List reviews={mockReviews} />)
-pozivamo metodu mockReviews.forEach()
-u funkciji forEach() pozivamo dvije funkcije expect() za varijable review.email i review.text
-kreiramo varijablu const stars 
-pozivamo funkciju expect() za varijablu stars